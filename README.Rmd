---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

# <img src="https://i.imgur.com/m8FNhQR.png" align="right" height=88 /> Functions for general purposes

[![lifecycle](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
[![Travis build status](https://travis-ci.org/forestgeo/fgeo.tool.svg?branch=master)](https://travis-ci.org/forestgeo/fgeo.tool)
[![Coverage status](https://coveralls.io/repos/github/forestgeo/fgeo.tool/badge.svg)](https://coveralls.io/r/forestgeo/fgeo.tool?branch=master)
[![CRAN status](https://www.r-pkg.org/badges/version/fgeo.tool)](https://cran.r-project.org/package=fgeo.tool)  

The goal of __fgeo.tool__ is to provide functions for general purposes.
Many of its functions are used in multiple other __fgeo__ packages so
__fgeo.tool__ acts as a central repository of code. In particular, the
packages. For general porpose functions with no expternal dependency see
[__fgeo.base__](https://forestgeo.github.io/fgeo.base/).

## Installation

```
# install.packages("remotes")
remotes::install_github("forestgeo/fgeo.tool")
```

For details on how to install packages from GitHub, see [this article](https://goo.gl/dQKEeg).

## Example

Setup.

```{r}
library(fgeo.tool)

df <- tibble::tribble(
  ~CensusID, ~TreeID, ~Status,
          1,    1, "alive",
          1,    1,  "dead",
                           
          1,    2,  "dead",
          1,    2,  "dead",
                           
          1,    3,  "dead",
          1,    3,  "dead",
                           
          2,    1, "alive",
          2,    1, "alive",
                           
          2,    2, "alive",
          2,    2,  "dead",
                           
          2,    3,  "dead",
          2,    3,  "dead"
)

```

Manipulate data.

```{r}
# Mutate a data set

# Determine the status of each tree based on the status of its stems
df <- add_status_tree(df)

# Filter a data set

# Filter from the head or tail of a variable
pick_top(df, TreeID)
pick_top(df, TreeID, -1)
# Remove trees found dead in two or more censuses
drop_twice_dead(df)
```

Much you can do directly with __dplyr__.

```{r}
# Using notation dplyr::fun to make it obvious where fun comes from
library(dplyr)

dplyr::filter(
  .data = df,
  CensusID > 1,
  TreeID  %in% c(1, 2),
  Status == "alive"
)
```

You can combine __fgeo.tool__ with __dplyr__.

```{r}
edited <- add_status_tree(pick_top(df, CensusID, -1))
dplyr::select(edited, -Status)
```

You don't have to, but if you want you can use the pipe (` %>% `).

```{r}
# With the pipe
df %>% 
  add_status_tree() %>%
  dplyr::filter(status_tree == "alive") %>%
  dplyr::rename(status_stem = Status) %>%
  dplyr::arrange(desc(CensusID))

# Same but without the pipe: It is hard to understand what is going on.
dplyr::arrange(
  dplyr::rename(
    dplyr::filter(
      add_status_tree(df), status_tree == "alive"), 
    status_stem = Status
  ), 
  desc(CensusID)
)
```

## Information

* [Getting help](SUPPORT.md).
* [Contributing](CONTRIBUTING.md).
* [Contributor Code of Conduct](CODE_OF_CONDUCT.md).

## Acknowledgements

Thanks to all partners of ForestGEO, for sharing their ideas and code.

