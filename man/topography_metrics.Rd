% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fgeo_habitat.R
\name{topography_metrics}
\alias{topography_metrics}
\alias{measure_topography}
\alias{cluster_elevation}
\alias{cluster_elevation.list}
\alias{cluster_elevation.data.frame}
\alias{measure_topography.data.frame}
\alias{measure_topography.list}
\title{Measure topography and apply hierarchical clustering.}
\usage{
\method{cluster_elevation}{list}(elevation, gridsize, n,
  only_elev = FALSE, edgecorrect = TRUE, ...)

\method{cluster_elevation}{data.frame}(elevation, gridsize, n,
  xdim = NULL, ydim = NULL, only_elev = FALSE, edgecorrect = TRUE,
  ...)

\method{measure_topography}{data.frame}(elevation, gridsize, xdim = NULL,
  ydim = NULL, edgecorrect = TRUE, ...)

\method{measure_topography}{list}(elevation, gridsize,
  edgecorrect = TRUE, ...)
}
\arguments{
\item{elevation}{One of these:
\itemize{
\item A list with at least three elements: \code{col} containing
elevation data; and \code{xdim} and \code{ydim} giving plot dimensions; OR
\item A dataframe containing elevation data, in which
case the parameters \code{xdim} and \code{ydim} must be provided. It may be the
element \code{col} of a ForestGEO elevation-list or an object of class
fgeo_elevation (see \code{\link[=fgeo_elevation]{fgeo_elevation()}}).
}}

\item{gridsize}{Number giving the size of each quadrat for which a habitat
is calculated. Commonly, \code{gridsize = 20}.}

\item{n}{Number of distinct habitat-categories to construct.}

\item{only_elev}{Should the clusters be calculated using only elevation?
\itemize{
\item If \code{FALSE} (default) habitats are calculated by applying
\code{\link[stats:kmeans]{stats::kmeans()}} clustering on all three topographic metrics from step 1.
\item If \code{TRUE} habitats are calculated by applying \code{\link[base:cut]{base::cut()}} on the mean
elevation from step 1 (ignoring convexity and slope).
}}

\item{edgecorrect}{Correct convexity in edge quadrats?}

\item{...}{Other arguments passed to methods.}

\item{xdim}{(If \code{elevation} is a dataframe) \code{x} and \code{y} dimensions of
the plot.}

\item{ydim}{(If \code{elevation} is a dataframe) \code{x} and \code{y} dimensions of
the plot.}
}
\value{
A dataframe.
}
\description{
These functions overlap, but -- depending on the context -- you may choose
one or the other to more clearly communicate your intention:
\itemize{
\item \code{measure_topography()} calculates mean elevation, convexity and slope.
\item \code{cluster_elevation()} outputs one additional column, \code{cluster}, calculated
by hierarchical clustering of the topographic metrics calculated by
\code{measure_topography()}. \code{cluster_elevation()} first calculates a
dissimilarities object (with \code{\link[stats:dist]{stats::dist()}} and all its defaults), then it
calculates a tree (with \code{\link[stats:hclust]{stats::hclust()}} and all its defaults), and finally
cuts the tree in \code{n} groups (with \code{\link[stats:cutree]{stats::cutree()}}).
}
}
\details{
The input can be either the elevation list that ForestGEO delivers, or the
element \code{col} of such list -- which is a dataframe containing the elevation
data. Notice that the required arguments to \code{fgeo_habitat()} vary according
to the main input (the elevation list or the elevation dataframe).
}
\examples{
elev_ls <- fgeo.data::luquillo_elevation
measure_topography(elev_ls, gridsize = 20)
cluster_elevation(elev_ls, gridsize = 20, n = 4)

elev_df <- elev_ls$col
measure_topography(elev_df, gridsize = 20, xdim = 320, ydim = 500)
cluster_elevation(elev_df, gridsize = 20, n = 4 , xdim = 320, ydim = 500)

# To decide the value of `n` you may inspect the dendrogram of topography.
topo <- measure_topography(elev_ls, gridsize = 20)
topo
topo_vars <- c("meanelev", "convex", "slope")
plot(hclust(dist(topo[topo_vars])))
}
\seealso{
\code{\link[=fgeo_habitat]{fgeo_habitat()}}.
}
